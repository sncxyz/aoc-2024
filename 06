import run, nd;

use nd.(Vec2, Matrix, v, vector.(n, s, e, w));

fn main() run.day 6 shared part_1 part_2;

fn shared(input) {
    map := Matrix.new(input split '\n');
    guard := map enumerate find (\(x) x[1] == '^');
    start := guard[0];
    map[start] = '.';
    pos := start;
    visited := set([pos]);
    dir := n();
    while map in_bounds (pos + dir) {
        if map[pos + dir] == '#' {
            dir perp=;
        } else {
            pos += dir;
            visited insert= pos;
        }
    }
    return [map, start, visited];
}

fn part_1(input) input[2] len;

fn part_2(input) {
    map := input[0];
    start := input[1];
    candidates := input[2] remove start;

    width := map width;
    height := map height;

    up := Matrix.init(width, height, nil);
    for x in 0 to width {
        dest := nil;
        for y in 0 to height {
            if map[v(x, y)] == '#' {
                dest = v(x, y + 1);
            } else {
                up[v(x, y)] = dest;
            }
        }
    }

    right := Matrix.init(width, height, nil);
    for y in 0 to height {
        dest := nil;
        for x in 0 to width rev {
            if map[v(x, y)] == '#' {
                dest = v(x - 1, y);
            } else {
                right[v(x, y)] = dest;
            }
        }
    }

    down := Matrix.init(width, height, nil);
    for x in 0 to width {
        dest := nil;
        for y in 0 to height rev {
            if map[v(x, y)] == '#' {
                dest = v(x, y - 1);
            } else {
                down[v(x, y)] = dest;
            }
        }
    }

    left := Matrix.init(width, height, nil);
    for y in 0 to height {
        dest := nil;
        for x in 0 to width {
            if map[v(x, y)] == '#' {
                dest = v(x + 1, y);
            } else {
                left[v(x, y)] = dest;
            }
        }
    }

    dests := [up, right, down, left];
    total := 0;

    for obstr in candidates list {
        remapped_dests := [];
        for dir in [s(), w(), n(), e()] {
            dests := Map.new();
            pos := obstr + dir;
            dest := pos;
            while map get pos is '.' {
                dests[pos] = dest;
                pos += dir;
            }
            remapped_dests push= dests;
        }

        visited := [Set.new()] * 4;
        dir := 0;
        pos := start;
        loop {
            new := remapped_dests[dir] get pos;
            if new {
                pos = new;
            } else {
                new := dests[dir][pos];
                if new {
                    pos = new;
                } else {
                    break;
                }
            }
            dir = dir + 1 mod 4;
            if visited[dir] contains pos {
                total += 1;
                break;
            }
            visited[dir] insert= pos;
        }
    }

    return total;
}
